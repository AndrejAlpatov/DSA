window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src.xml_handler.__init__", "modulename": "src.xml_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.xml_handler.XMLManager", "modulename": "src.xml_handler.XMLManager", "type": "module", "doc": "<p>This module parses the data out of xml files and transfers them to the database</p>\n"}, {"fullname": "src.xml_handler.XMLManager.XMLFileReader", "modulename": "src.xml_handler.XMLManager", "qualname": "XMLFileReader", "type": "class", "doc": "<p>Class to Read XML Files</p>\n"}, {"fullname": "src.xml_handler.XMLManager.XMLFileReader.__init__", "modulename": "src.xml_handler.XMLManager", "qualname": "XMLFileReader.__init__", "type": "function", "doc": "<p>Initialisition for XMLFileReader Class</p>\n\n<p>day(stringArray): Array with all Values of Weekdays besides Saturday and Sunday\nself.client = establishes a connection with the connection string in the file_for_internal_usage\nself.database = getting access to MensaSkill Database</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.xml_handler.XMLManager.XMLFileReader.get_weekday", "modulename": "src.xml_handler.XMLManager", "qualname": "XMLFileReader.get_weekday", "type": "function", "doc": "<p>Function to get the date from the xml file where the essen is provided and calculate the weekday for the date</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>essen:</strong>  the current row of the xml document which is selected in the main function of the class.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The weekday that the meal (essen) is provided by the mensa</p>\n</blockquote>\n", "signature": "(self, essen)", "funcdef": "def"}, {"fullname": "src.xml_handler.XMLManager.XMLFileReader.calc_calender_week", "modulename": "src.xml_handler.XMLManager", "qualname": "XMLFileReader.calc_calender_week", "type": "function", "doc": "<p>A function to calculate the calenderweek by looking at the essen argument from the xml document with\n.getAttribute(\"PRODDATUM\") which returns the calender date on which the meal (essen) is served</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>essen:</strong>  the current row of the xml document which is selected in the main function of the class.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A valid Calender date fitting to the PRODDATUM</p>\n</blockquote>\n", "signature": "(essen)", "funcdef": "def"}, {"fullname": "src.xml_handler.XMLManager.XMLFileReader.get_data", "modulename": "src.xml_handler.XMLManager", "qualname": "XMLFileReader.get_data", "type": "function", "doc": "<p>The get_data function scans the XML File row by row and picks all rows where the Attribute DPORTNAME is equal\nto Mensa Worms. This Row with its arguments will be used to create our database entry in the Database Document\nwith the CalenderWeek the meal is provided in.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xml_file:</strong>  A valid XML File</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>void</p>\n</blockquote>\n", "signature": "(self, xml_file)", "funcdef": "def"}, {"fullname": "src.unvalid_question_handler.__init__", "modulename": "src.unvalid_question_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.unvalid_question_handler.unvalid_question_intent_handler", "modulename": "src.unvalid_question_handler.unvalid_question_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the UnvalidQuestionIntent</p>\n"}, {"fullname": "src.unvalid_question_handler.unvalid_question_intent_handler.UnvalidQuestionIntentHandler", "modulename": "src.unvalid_question_handler.unvalid_question_intent_handler", "qualname": "UnvalidQuestionIntentHandler", "type": "class", "doc": "<p>Handler for UnvalidQuestionIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.unvalid_question_handler.unvalid_question_intent_handler.UnvalidQuestionIntentHandler.__init__", "modulename": "src.unvalid_question_handler.unvalid_question_intent_handler", "qualname": "UnvalidQuestionIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.unvalid_question_handler.unvalid_question_intent_handler.UnvalidQuestionIntentHandler.can_handle", "modulename": "src.unvalid_question_handler.unvalid_question_intent_handler", "qualname": "UnvalidQuestionIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.unvalid_question_handler.unvalid_question_intent_handler.UnvalidQuestionIntentHandler.handle", "modulename": "src.unvalid_question_handler.unvalid_question_intent_handler", "qualname": "UnvalidQuestionIntentHandler.handle", "type": "function", "doc": "<p>The method returns a notice, that the user asked\na invalid question.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.__init__", "modulename": "src.studierendenwerk_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "modulename": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the OperatorOfMensaIntent</p>\n"}, {"fullname": "src.studierendenwerk_handler.operator_of_mensa_intent_handler.OperatorOfMensaIntentHandler", "modulename": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "qualname": "OperatorOfMensaIntentHandler", "type": "class", "doc": "<p>Handler for OperatorOfMensaIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.studierendenwerk_handler.operator_of_mensa_intent_handler.OperatorOfMensaIntentHandler.__init__", "modulename": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "qualname": "OperatorOfMensaIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.operator_of_mensa_intent_handler.OperatorOfMensaIntentHandler.can_handle", "modulename": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "qualname": "OperatorOfMensaIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.operator_of_mensa_intent_handler.OperatorOfMensaIntentHandler.handle", "modulename": "src.studierendenwerk_handler.operator_of_mensa_intent_handler", "qualname": "OperatorOfMensaIntentHandler.handle", "type": "function", "doc": "<p>The method returns the information, by who the mensa gets leaded.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "modulename": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the StudierendenWerkActivityIntent</p>\n"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler.StudierendenWerkActivityIntentHandler", "modulename": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "qualname": "StudierendenWerkActivityIntentHandler", "type": "class", "doc": "<p>Handler for StudierendenWerkActivityIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler.StudierendenWerkActivityIntentHandler.__init__", "modulename": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "qualname": "StudierendenWerkActivityIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler.StudierendenWerkActivityIntentHandler.can_handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "qualname": "StudierendenWerkActivityIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler.StudierendenWerkActivityIntentHandler.handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_activity_intent_handler", "qualname": "StudierendenWerkActivityIntentHandler.handle", "type": "function", "doc": "<p>The method returns informations about all the activities of the Studierendenwerk.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "modulename": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the StudierendenwerkInfoIntent</p>\n"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler.StudierendenwerkInfoIntentHandler", "modulename": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "qualname": "StudierendenwerkInfoIntentHandler", "type": "class", "doc": "<p>Handler for StudierendenwerkInfoIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler.StudierendenwerkInfoIntentHandler.__init__", "modulename": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "qualname": "StudierendenwerkInfoIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler.StudierendenwerkInfoIntentHandler.can_handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "qualname": "StudierendenwerkInfoIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler.StudierendenwerkInfoIntentHandler.handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_info_intent_handler", "qualname": "StudierendenwerkInfoIntentHandler.handle", "type": "function", "doc": "<p>The method returns an general expanation about the Studierendenwerk.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "modulename": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the StudierendenwerkOtherMensenIntent</p>\n"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler.StudierendenwerkOtherMensenIntentHandler", "modulename": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "qualname": "StudierendenwerkOtherMensenIntentHandler", "type": "class", "doc": "<p>Handler for StudierendenwerkOtherMensenIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler.StudierendenwerkOtherMensenIntentHandler.__init__", "modulename": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "qualname": "StudierendenwerkOtherMensenIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler.StudierendenwerkOtherMensenIntentHandler.can_handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "qualname": "StudierendenwerkOtherMensenIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler.StudierendenwerkOtherMensenIntentHandler.handle", "modulename": "src.studierendenwerk_handler.studierendenwerk_other_mensen_intent_handler", "qualname": "StudierendenwerkOtherMensenIntentHandler.handle", "type": "function", "doc": "<p>The method returns a list of other mensen, which are getting\nleaded by the Studierendenwerk.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.closing_hours_handler", "modulename": "src.opening_hours_handler.closing_hours_handler", "type": "module", "doc": "<p>This module contains the handler for the ClosingHoursIntent</p>\n"}, {"fullname": "src.opening_hours_handler.closing_hours_handler.ClosingHoursIntentHandler", "modulename": "src.opening_hours_handler.closing_hours_handler", "qualname": "ClosingHoursIntentHandler", "type": "class", "doc": "<p>Handler for ClosingHoursIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.opening_hours_handler.closing_hours_handler.ClosingHoursIntentHandler.__init__", "modulename": "src.opening_hours_handler.closing_hours_handler", "qualname": "ClosingHoursIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.closing_hours_handler.ClosingHoursIntentHandler.can_handle", "modulename": "src.opening_hours_handler.closing_hours_handler", "qualname": "ClosingHoursIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.closing_hours_handler.ClosingHoursIntentHandler.handle", "modulename": "src.opening_hours_handler.closing_hours_handler", "qualname": "ClosingHoursIntentHandler.handle", "type": "function", "doc": "<p>The method returns closing hours, in relation to the given department.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot values)</li>\n<li><strong>Slot:</strong>  mensa_department: 'mensa', 'kiosk', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.closing_hours_handler.ClosingHoursIntentHandler.test", "modulename": "src.opening_hours_handler.closing_hours_handler", "qualname": "ClosingHoursIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.__init__", "modulename": "src.opening_hours_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.opening_hours_handler.opening_hours_handler", "modulename": "src.opening_hours_handler.opening_hours_handler", "type": "module", "doc": "<p>This module contains the handler for the OpeningHoursIntent</p>\n"}, {"fullname": "src.opening_hours_handler.opening_hours_handler.OpeningHoursIntentHandler", "modulename": "src.opening_hours_handler.opening_hours_handler", "qualname": "OpeningHoursIntentHandler", "type": "class", "doc": "<p>Handler for OpeningHoursIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.opening_hours_handler.opening_hours_handler.OpeningHoursIntentHandler.__init__", "modulename": "src.opening_hours_handler.opening_hours_handler", "qualname": "OpeningHoursIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_hours_handler.OpeningHoursIntentHandler.can_handle", "modulename": "src.opening_hours_handler.opening_hours_handler", "qualname": "OpeningHoursIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_hours_handler.OpeningHoursIntentHandler.handle", "modulename": "src.opening_hours_handler.opening_hours_handler", "qualname": "OpeningHoursIntentHandler.handle", "type": "function", "doc": "<p>The method returns opening hours, in relation to the given department.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot values)</li>\n<li><strong>Slot:</strong>  mensa_department: 'mensa', 'kiosk', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_hours_handler.OpeningHoursIntentHandler.test", "modulename": "src.opening_hours_handler.opening_hours_handler", "qualname": "OpeningHoursIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_time_handler", "modulename": "src.opening_hours_handler.opening_time_handler", "type": "module", "doc": "<p>This module contains the handler for the OpeningTimeIntent</p>\n"}, {"fullname": "src.opening_hours_handler.opening_time_handler.OpeningTimesIntentHandler", "modulename": "src.opening_hours_handler.opening_time_handler", "qualname": "OpeningTimesIntentHandler", "type": "class", "doc": "<p>Handler for OpeningtimeIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.opening_hours_handler.opening_time_handler.OpeningTimesIntentHandler.__init__", "modulename": "src.opening_hours_handler.opening_time_handler", "qualname": "OpeningTimesIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_time_handler.OpeningTimesIntentHandler.can_handle", "modulename": "src.opening_hours_handler.opening_time_handler", "qualname": "OpeningTimesIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_time_handler.OpeningTimesIntentHandler.handle", "modulename": "src.opening_hours_handler.opening_time_handler", "qualname": "OpeningTimesIntentHandler.handle", "type": "function", "doc": "<p>The method returns opening and closing hours, in relation to the given department.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot values)</li>\n<li><strong>Slot:</strong>  mensa_department: 'mensa', 'kiosk', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.opening_hours_handler.opening_time_handler.OpeningTimesIntentHandler.test", "modulename": "src.opening_hours_handler.opening_time_handler", "qualname": "OpeningTimesIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.__init__", "modulename": "src.mensa_preis_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the PriceQueryIntent</p>\n"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler", "type": "class", "doc": "<p>Handler for PriceQueryIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler.__init__", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler.activate_session", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler.activate_session", "type": "function", "doc": "<p>The method activates the price session for user, using the database.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>db_collection_session():</strong>  An object of a DB collection, which stores user session documents</li>\n<li><strong>user_id(string):</strong>  A unique user identifier</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>void</p>\n</blockquote>\n", "signature": "(self, db_collection_session, user_id)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler.deactivate_session", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler.deactivate_session", "type": "function", "doc": "<p>The method deactivates the price session of the user, using the database.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>db_collection_session():</strong>  An object of a DB collection, which stores user session documents</li>\n<li><strong>user_id(string):</strong>  A unique user identifier</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>void</p>\n</blockquote>\n", "signature": "(self, db_collection_session, user_id)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler.can_handle", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_intent_handler.PriceQueryIntentHandler.handle", "modulename": "src.mensa_preis_handler.price_query_intent_handler", "qualname": "PriceQueryIntentHandler.handle", "type": "function", "doc": "<p>The method returns the price of the meal, in relation to the membership.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (4 slot values)</li>\n<li><strong>Slot:</strong>  day_price: 'Montag', 'Dienstag', ...</li>\n<li><strong>Slot:</strong>  membership_price: 'Student', 'Gast', ...</li>\n<li><strong>Slot:</strong>  timeindication_price: 'morgen', 'gestern', ...</li>\n<li><strong>Slot:</strong>  num_days: '1', '2', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the PriceQuerySessionIntent</p>\n"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler.PriceQuerySessionIntentHandler", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "qualname": "PriceQuerySessionIntentHandler", "type": "class", "doc": "<p>Handler for PriceQuerySessionIntent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler.PriceQuerySessionIntentHandler.__init__", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "qualname": "PriceQuerySessionIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler.PriceQuerySessionIntentHandler.deactivate_session", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "qualname": "PriceQuerySessionIntentHandler.deactivate_session", "type": "function", "doc": "<p>The method deactivates price sessions of the user, using the database.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>db_collection_session():</strong>  An object of a DB collection, which stores user session documents</li>\n<li><strong>user_id(string):</strong>  A unique user identifier</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>void</p>\n</blockquote>\n", "signature": "(self, db_collection_session, user_id)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler.PriceQuerySessionIntentHandler.can_handle", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "qualname": "PriceQuerySessionIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_preis_handler.price_query_session_intent_handler.PriceQuerySessionIntentHandler.handle", "modulename": "src.mensa_preis_handler.price_query_session_intent_handler", "qualname": "PriceQuerySessionIntentHandler.handle", "type": "function", "doc": "<p>If the user has an active price session, the method returns the price of the meal,\nin relation to the given membership.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot value)</li>\n<li><strong>Slot:</strong>  membership_price_session: 'Student', 'Gast', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_handler.__init__", "modulename": "src.mensa_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.mensa_handler.query_menu_intent_handler", "modulename": "src.mensa_handler.query_menu_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the QueryMenuIntent</p>\n"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler", "type": "class", "doc": "<p>Handler for QueryMenuIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.__init__", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.apl_document_path", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.apl_document_path", "type": "variable", "doc": "<p></p>\n", "default_value": " = PosixPath('/home/danny/Documents/3.Semester/DSA/MensaSkill/DSA/src/mensa_handler/../../res/queryMenuAPLdocument.json')"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.writeToJsonFile", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.writeToJsonFile", "type": "function", "doc": "<p>The method loads the apl json document and updates the entry of the meal attribute.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>speech_text(string):</strong>  The text, which is a part of the response of the intent, is\nused to update the apl json document</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>void</p>\n</blockquote>\n", "signature": "(self, speech_text)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.load_apl_document", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.load_apl_document", "type": "function", "doc": "<p>The method loads the apl json document at the path into a dict object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>file_path(string):</strong>  The path to the apl json document.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>json.load(f)(dictionary): The apl document</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.can_handle", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.handle", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.handle", "type": "function", "doc": "<p>The method returns the meal, in relation to the date and ausgabe.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (5 slot values)</li>\n<li><strong>Slot:</strong>  date_for_menu_query: '2022-02-04', '2022-01-29', ...</li>\n<li><strong>Slot:</strong>  week_day: 'Montag', 'Dienstag', ...</li>\n<li><strong>Slot:</strong>  time_indication: 'morgen', 'gestern', ...</li>\n<li><strong>Slot:</strong>  ausgabe: 'eins', 'zwei', ...</li>\n<li><strong>Slot:</strong>  number_of_days_ahead: '2', '3', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_intent_handler.QueryMenuIntentHandler.test", "modulename": "src.mensa_handler.query_menu_intent_handler", "qualname": "QueryMenuIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "type": "module", "doc": "<p>This module contains the handler for the QueryMenuWithAdditives</p>\n"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler.QueryMenuWithAdditivesIntentHandler", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "qualname": "QueryMenuWithAdditivesIntentHandler", "type": "class", "doc": "<p>Handler for Question \"was gibt es heute mit [Zusatzstoff] zum essen\"</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler.QueryMenuWithAdditivesIntentHandler.__init__", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "qualname": "QueryMenuWithAdditivesIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler.QueryMenuWithAdditivesIntentHandler.can_handle", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "qualname": "QueryMenuWithAdditivesIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler.QueryMenuWithAdditivesIntentHandler.handle", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "qualname": "QueryMenuWithAdditivesIntentHandler.handle", "type": "function", "doc": "<p>A Class for the \"QueryMenuWithAdditivesIntent\" in this class we check the value of DATEFORMENUQUERY, WEEKDAY,\nTIMEINDICATION, NUMBERSOFDAYSAHEAD if one of them is set we format them in the way DATEFORMENUQUERY is presented\nand then call the method output_for_query_menu_with_additives_intent</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input:</strong>  The Utterance that triggers the Intent (6 slot values)</li>\n<li><strong>Slot:</strong>  DATEFORMENUQUERY: A date with format MM/DD/YYYY</li>\n<li><strong>Slot:</strong>  WEEKDAY: \"Montag\", \"Dienstag\", ...</li>\n<li><strong>Slot:</strong>  TIMEINDICATION: \"morgen\" , \"gestern\", ...</li>\n<li><strong>Slot:</strong>  NUMBEROFDAYSAHEAD: \"1\", \"2\",...</li>\n<li><strong>Slot:</strong>  WITHORWITHOUT: \"mit\", \"ohne\"</li>\n<li><strong>Slot:</strong>  ADDITIVES: \"S\u00fc\u00dfungsmittel\", \"Schweinefleisch\", \"Fisch\", \"N\u00fcsse\",...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.ask(speech_text).response: A speech_text for the Alexa Output</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.mensa_handler.query_menu_with_additives_handler.QueryMenuWithAdditivesIntentHandler.test", "modulename": "src.mensa_handler.query_menu_with_additives_handler", "qualname": "QueryMenuWithAdditivesIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.launch_request_handler.__init__", "modulename": "src.launch_request_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.launch_request_handler.launch_request_handler", "modulename": "src.launch_request_handler.launch_request_handler", "type": "module", "doc": "<p>This module contains the handler for the Skill Launch</p>\n"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler", "type": "class", "doc": "<p>Handler for Skill Launch.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler.__init__", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler.apl_document_path", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler.apl_document_path", "type": "variable", "doc": "<p></p>\n", "default_value": " = PosixPath('/home/danny/Documents/3.Semester/DSA/MensaSkill/DSA/src/launch_request_handler/../../res/launchAPLdocument.json')"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler.load_apl_document", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler.load_apl_document", "type": "function", "doc": "<p>The method loads the apl json document at the path into a dict object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>file_path(string):</strong>  The path to the apl json document.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>json.load(f)(dictionary): The apl document</p>\n</blockquote>\n", "signature": "(self, file_path)", "funcdef": "def"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler.can_handle", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.launch_request_handler.launch_request_handler.LaunchRequestHandler.handle", "modulename": "src.launch_request_handler.launch_request_handler", "qualname": "LaunchRequestHandler.handle", "type": "function", "doc": "<p>The method greets the user and additionally explains the functionality of the skill,\nif that user launches the skill for the fist time.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "type": "module", "doc": "<p>This module contains the handler for the OwnCupInKioskHandler</p>\n"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler.OwnCupInKioskHandler", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "qualname": "OwnCupInKioskHandler", "type": "class", "doc": "<p>Handler for OwnCupInKioskHandler</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler.OwnCupInKioskHandler.__init__", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "qualname": "OwnCupInKioskHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler.OwnCupInKioskHandler.can_handle", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "qualname": "OwnCupInKioskHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler.OwnCupInKioskHandler.handle", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "qualname": "OwnCupInKioskHandler.handle", "type": "function", "doc": "<p>The method answers the question if it's allowed to bring a own cup into the mensa.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.additional_kiosk_questions_handler.OwnCupInKioskHandler.test", "modulename": "src.kiosk_handler.additional_kiosk_questions_handler", "qualname": "OwnCupInKioskHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.kiosk_handler.__init__", "modulename": "src.kiosk_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the KioskMenuIfIntent and the KioskMenuWhatIntent</p>\n"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuIfIntentHandler", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuIfIntentHandler", "type": "class", "doc": "<p>Handler for KioskMenuIfIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuIfIntentHandler.__init__", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuIfIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuIfIntentHandler.can_handle", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuIfIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuIfIntentHandler.handle", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuIfIntentHandler.handle", "type": "function", "doc": "<p>The method returns 'Ja, ...' or 'Nein, ...' if special products are available in the kiosk or not.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot values)</li>\n<li><strong>Slot:</strong>  kiosk_menu: 'zum trinken', 's\u00fc\u00dfwaren', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuIfIntentHandler.test", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuIfIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuWhatIntentHandler", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuWhatIntentHandler", "type": "class", "doc": "<p>Handler for KioskMenuWhatIntent</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuWhatIntentHandler.__init__", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuWhatIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuWhatIntentHandler.can_handle", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuWhatIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuWhatIntentHandler.handle", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuWhatIntentHandler.handle", "type": "function", "doc": "<p>The method returns a list of available products in the kiosk, in relation to the given product category.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (1 slot values)</li>\n<li><strong>Slot:</strong>  kiosk_menu: 'zum trinken', 's\u00fc\u00dfwaren', ...</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.kiosk_handler.kiosk_menu_intent_handler.KioskMenuWhatIntentHandler.test", "modulename": "src.kiosk_handler.kiosk_menu_intent_handler", "qualname": "KioskMenuWhatIntentHandler.test", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.help_intent_handler.help_intent_handler", "modulename": "src.help_intent_handler.help_intent_handler", "type": "module", "doc": "<p>This module contains the handler for the Help Intent</p>\n"}, {"fullname": "src.help_intent_handler.help_intent_handler.HelpIntentHandler", "modulename": "src.help_intent_handler.help_intent_handler", "qualname": "HelpIntentHandler", "type": "class", "doc": "<p>Handler for Help Intent.</p>\n", "bases": "typing.Generic[~Input, ~Output]"}, {"fullname": "src.help_intent_handler.help_intent_handler.HelpIntentHandler.__init__", "modulename": "src.help_intent_handler.help_intent_handler", "qualname": "HelpIntentHandler.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.help_intent_handler.help_intent_handler.HelpIntentHandler.can_handle", "modulename": "src.help_intent_handler.help_intent_handler", "qualname": "HelpIntentHandler.can_handle", "type": "function", "doc": "<p>Returns true if Request Handler can handle the Request\ninside Handler Input.</p>\n\n<p>:param handler_input: Handler Input instance with\n    Request Envelope containing Request.\n:type handler_input: HandlerInput\n:return: Boolean value that tells the dispatcher if the\n    current request can be handled by this handler.\n:rtype: bool</p>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.help_intent_handler.help_intent_handler.HelpIntentHandler.handle", "modulename": "src.help_intent_handler.help_intent_handler", "qualname": "HelpIntentHandler.handle", "type": "function", "doc": "<p>The method explains the skill functionality and gives a list of utterance examples to the user,\nif the user needs help.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handler_input(HandlerInput):</strong>  The utterance that triggered the Intent (no slot values)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>handler_input.response_builder.response(Response): Response for the Intent</p>\n</blockquote>\n", "signature": "(self, handler_input)", "funcdef": "def"}, {"fullname": "src.help_intent_handler.__init__", "modulename": "src.help_intent_handler.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.ftp.FTPManager", "modulename": "src.ftp.FTPManager", "type": "module", "doc": "<p>This module contains an interface to the FTP-Server</p>\n"}, {"fullname": "src.ftp.FTPManager.check_for_new_data", "modulename": "src.ftp.FTPManager", "qualname": "check_for_new_data", "type": "function", "doc": "<p>Function that establishes a SSH connection to a SFTP-server which is then used to download data from the SFTP Server\nwhen there is no new data nothing will be downloaded if there is new data the function will provide a list of all\nthe files that are new and download them to the res repository. The downloaded files will be moved to another\nrepository to be reused if something went wrong.</p>\n\n<p>Returns: A List of files_to_fetch if there is new data or a empty list if there is no data</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.ftp.__init__", "modulename": "src.ftp.__init__", "type": "module", "doc": "<p></p>\n"}, {"fullname": "change_list_values_to_lower_case", "modulename": "change_list_values_to_lower_case", "type": "module", "doc": "<p>This module contains a helper function for list value manipulations</p>\n"}, {"fullname": "change_list_values_to_lower_case.list_value_to_low_case", "modulename": "change_list_values_to_lower_case", "qualname": "list_value_to_low_case", "type": "function", "doc": "<p>Get a string from lowercase and uppercase characters and returns a new\none which consists only of a lowercase characters</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>list_in(list):</strong>  list with strings</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list that comprises strings in lower case</p>\n</blockquote>\n", "signature": "(list_in)", "funcdef": "def"}, {"fullname": "create_string_from_list_values", "modulename": "create_string_from_list_values", "type": "module", "doc": "<p>This module contains a helper function for combining list elements\nto one string, that gets appended to a new list</p>\n"}, {"fullname": "create_string_from_list_values.create_strings_from_list_values", "modulename": "create_string_from_list_values", "qualname": "create_strings_from_list_values", "type": "function", "doc": "<p>Combines input parameter elements to one string, that gets appended to a new list</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>list_menus(List):</strong>  A list with all menu components (database entries)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list_with_menu_strings_to_be_returned(List): Shortened list with important menu components as strings</p>\n</blockquote>\n", "signature": "(list_menus)", "funcdef": "def"}, {"fullname": "get_menu_from_db", "modulename": "get_menu_from_db", "type": "module", "doc": "<p>This module contains a function to get the menu entries for particular date from the database</p>\n"}, {"fullname": "get_menu_from_db.get_menus_from_db", "modulename": "get_menu_from_db", "qualname": "get_menus_from_db", "type": "function", "doc": "<p>Returns all values for key value 'menu' from DB-collection,\n where collection name ist equal to calender week of input parameter date_as_str</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_str(string):</strong>  date value as a string in format DD.MM.YYYY</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list with all menu values</p>\n</blockquote>\n", "signature": "(date_as_str)", "funcdef": "def"}, {"fullname": "output_for_query_menu_intent", "modulename": "output_for_query_menu_intent", "type": "module", "doc": "<p>This module calculates outputs for the QueryMenuIntent</p>\n"}, {"fullname": "output_for_query_menu_intent.output_for_query_menu_intent", "modulename": "output_for_query_menu_intent", "qualname": "output_for_query_menu_intent", "type": "function", "doc": "<p>Returns particular \"Ausgabe\" for Ausgabe number == slot_value_ausgabe and date == date_for_output as a string</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>slot_value_ausgabe:</strong>  Number of \"Ausgabe\" e.g. \"Ausgabe 1\", \"2\"</li>\n<li><strong>date_for_output(string):</strong>  date in a string format DD.MM.YYYY</li>\n</ul>\n\n<p>Returns:\nSpeech text for Alexa-response as a string</p>\n", "signature": "(slot_value_ausgabe, date_for_output)", "funcdef": "def"}, {"fullname": "output_for_query_menu_with_additives_intent", "modulename": "output_for_query_menu_with_additives_intent", "type": "module", "doc": "<p>This module calculates outputs for the QueryMenuWithAdditivesIntent</p>\n"}, {"fullname": "output_for_query_menu_with_additives_intent.output_for_query_menu_with_additives_intent", "modulename": "output_for_query_menu_with_additives_intent", "qualname": "output_for_query_menu_with_additives_intent", "type": "function", "doc": "<p>Function to help us find the fitting output for the QueryMenuWithAdditivesIntent with the given Arguments.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date(string):</strong>  A date in the DD.MM.YYYY format</li>\n<li><strong>additive(string):</strong>  One of the values that the ADDITIVE slot offers</li>\n<li><strong>with_or_without(string):</strong>  either has the value \"mit\" or \"ohne\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A fitting speech_text(String) for the given arguments.</p>\n</blockquote>\n", "signature": "(date, additive, with_or_without)", "funcdef": "def"}, {"fullname": "output_of_all_collections", "modulename": "output_of_all_collections", "type": "module", "doc": "<p>This module contains an interfaces for the MongoDB Cloud Atlas</p>\n"}, {"fullname": "output_of_all_collections.data_bank_access", "modulename": "output_of_all_collections", "qualname": "data_bank_access", "type": "function", "doc": "<p>Returns collections which names were passed as a list of strings</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>collections_names_in(list):</strong>  List of a strings. Strings are the names of collections that have to be returned</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Collections from MongoDB which names a passed as a parameter</p>\n</blockquote>\n", "signature": "(collections_names_in)", "funcdef": "def"}, {"fullname": "time_functions", "modulename": "time_functions", "type": "module", "doc": "<p>This module contains functions to manage time and date formats</p>\n"}, {"fullname": "time_functions.current_week_day", "modulename": "time_functions", "qualname": "current_week_day", "type": "function", "doc": "<p>The function returns the current week day</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>weekday(int): The number from 0 to 6, which refers to the current week day</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "time_functions.convert_string_to_datetime_object", "modulename": "time_functions", "qualname": "convert_string_to_datetime_object", "type": "function", "doc": "<p>Converts a string in format DD.MM.YYYY to a datetime-object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_string(string):</strong>  String in format DD.MM.YYYY, that have to be converted to datetime-object</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(datetime-object): date as datetime-object</p>\n</blockquote>\n", "signature": "(date_as_string)", "funcdef": "def"}, {"fullname": "time_functions.convert_datetime_object_to_string", "modulename": "time_functions", "qualname": "convert_datetime_object_to_string", "type": "function", "doc": "<p>Converts datetime object to a string in format DD.MM:YYYY</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_object(datetime):</strong>  date as a datetime object</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(string): date in a string format DD.MM:YYYY</p>\n</blockquote>\n", "signature": "(date_as_object)", "funcdef": "def"}, {"fullname": "time_functions.week_day_for_date", "modulename": "time_functions", "qualname": "week_day_for_date", "type": "function", "doc": "<p>Returns week day for particular date. Values from 0 (Monday) to 6 (Sunday)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_str(string):</strong>  date in a string format DD.MM.YYY</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>weekday(int): Values in range from 0 to 6</p>\n</blockquote>\n", "signature": "(date_as_str)", "funcdef": "def"}, {"fullname": "time_functions.current_week_number", "modulename": "time_functions", "qualname": "current_week_number", "type": "function", "doc": "<p>Returns current calendar week number</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>calendar_week(int): calendar week number in range from 1 bis 53</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "time_functions.week_number_for_date", "modulename": "time_functions", "qualname": "week_number_for_date", "type": "function", "doc": "<p>Returns calendar week number for particular date</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_str(string):</strong>  date in a string format DD.MM.YYY</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>calendar_week(int): calendar week number in range from 1 bis 53</p>\n</blockquote>\n", "signature": "(date_as_str)", "funcdef": "def"}, {"fullname": "time_functions.correction_of_date_string", "modulename": "time_functions", "qualname": "correction_of_date_string", "type": "function", "doc": "<p>Corrects string from not complete format to DD.MM.YYYY format</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>date_as_str(string):</strong>  Date in formats like XXXX-XX-11</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(string): date as a string in format XX.XX.XXXX</p>\n</blockquote>\n", "signature": "(date_as_str)", "funcdef": "def"}, {"fullname": "time_functions.convert_week_day_from_number_to_wort", "modulename": "time_functions", "qualname": "convert_week_day_from_number_to_wort", "type": "function", "doc": "<p>change week day as number(0..6) in natural language (Montag..Sonntag)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>day_as_number()int:</strong>  Day of the week as a number in a range 0..6 (Montag..Sonntag)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>day(string): Values from Montag to Sonntag</p>\n</blockquote>\n", "signature": "(day_as_number)", "funcdef": "def"}, {"fullname": "time_functions.get_dates_for_current_week", "modulename": "time_functions", "qualname": "get_dates_for_current_week", "type": "function", "doc": "<p>Returns dates (as a list) for all days of the current week</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dates(list): Dates of the current week as a string in a list []</p>\n</blockquote>\n", "signature": "()", "funcdef": "def"}, {"fullname": "time_functions.get_date_for_week_day_of_current_week", "modulename": "time_functions", "qualname": "get_date_for_week_day_of_current_week", "type": "function", "doc": "<p>Returns date for week day of current week. ex for Friday</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>week_day(string):</strong>  Week days as a string value e.g. donnerstag, sonntag</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(string): date as s string for input week day</p>\n</blockquote>\n", "signature": "(week_day)", "funcdef": "def"}, {"fullname": "time_functions.get_date_for_time_indication_values", "modulename": "time_functions", "qualname": "get_date_for_time_indication_values", "type": "function", "doc": "<p>Returns date for a day, which specified by value of parameter which is a Alexa slot type time_indication</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>time_indication(string):</strong>  time indication such as \"heute\", \"morgen\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(string): date for a day that indicated relative to current date e.g. tomorrow, yesterday</p>\n</blockquote>\n", "signature": "(time_indication)", "funcdef": "def"}, {"fullname": "time_functions.get_date_for_days_ahead_intent", "modulename": "time_functions", "qualname": "get_date_for_days_ahead_intent", "type": "function", "doc": "<p>Returns date for a day, which is n-days ahead, where n is a slot value from intent</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>days_ahead_in:</strong>  could be a number from 2 to 5, einem oder \"einer woche\"</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date(string): date for the date, which is indicates with parameter related to current day</p>\n</blockquote>\n", "signature": "(days_ahead_in)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();